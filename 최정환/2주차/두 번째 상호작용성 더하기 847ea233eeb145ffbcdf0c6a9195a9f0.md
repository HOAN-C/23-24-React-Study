# 두 번째 : 상호작용성 더하기

# 이벤트에 응답하기

## 버튼 태그에 onClick 이라는 속성을 사용하여  클릭시 동작을 지정할 수 있다.

- 속성 내에 함수를 추가하면 된다.
- 하지만 ‘호출’이 아닌 ‘전달’되어야 한다.
- 바로 전달할 수 있지만(alert(’Hello’)); 이렇게 되면 컴포넌트가 랜더링 될 때 마다 함수가 실행된다.
- 이벤트 핸들러 내에서 Prop 읽기
    - props를 통해 전달하면 함수에서 props를 읽을 수 있다.

## 이벤트 핸들러를 Prop으로 전달하기

- 컴포넌트 안 컴포넌트에 props를 사용하여 데이터를 전달할 수 있다.
- e.g) Button 컴포넌트 재활용

## 이벤트 핸들러 Prop 명명하기

- Button컴포넌트를 통해 button 태그에 onClick을 전달할 때 꼭 onClick일 필요가 없다.

## 이벤트 전파

- div 안에 div가 있는데, 둘 다 onClick 속성이 할당되어 있다면?
- 버튼을 클릭하면
    - 자식의 onClick먼저 실행 후 부모의 onClick이 실행됨.
- 부모 div를 클릭하면 부모의 onClick만 실행

## 전파 멈추기

- 이벤트 핸들러는 이벤트 오브젝트를 유일한 매개변수로 받는다.
    - 관습에 따라 e로 호출되는 것이 일반적.
- 위 ‘이벤트 전파’ 에서 부모의 이벤트 실행을 막기 위해선?
- e.stopPropagation() 사용
- 버튼 클릭 수 실행 순서
1. React가 `<button>`에 전달된 `onClick` 핸들러를 호출합니다.
2. `Button`에 정의된 해당 핸들러는 다음을 수행합니다.
    - `e.stopPropagation()`을 호출하여 이벤트가 더 이상 bubbling 되지 않도록 방지합니다.
    - `Toolbar` 컴포넌트가 전달해 준 `onClick` 함수를 호출합니다.
3. `Toolbar` 컴포넌트에서 정의된 위 함수가 버튼의 alert를 표시합니다.
4. 전파가 중단되었으므로 부모인 `<div>`의 `onClick`은 *실행되지 않습니다*.

→ break와 비슷한 효과?

## 전파의 대안으로 핸들러 전달

- ??? 이해가 잘 안됨..

## 기본 동작 방지하기

- form을 onSubmit 하는 동작은 페이지를 리로드하게 된다.
- 하지만,, 요즘엔 리로드가 필요없기에 리로드 동작을 방지할 필요가 있다.

- `[e.stopPropagation()](https://developer.mozilla.org/docs/Web/API/Event/stopPropagation)`은 이벤트 핸들러가 상위 태그에서 실행되지 않도록 멈춥니다.
- `[e.preventDefault()`](https://developer.mozilla.org/docs/Web/API/Event/preventDefault) 는 기본 브라우저 동작을 가진 일부 이벤트가 해당 기본 동작을 실행하지 않도록 방지합니다.

## 이벤트 핸들러가 사이드 이펙트를 가질 수도 있나?

- 가능하다! 오히려 많이 쓴다.
    - 이벤트 핸들러는 순수할 필요가 없다.??
    - 무언가를 변경하는데 최적의 위치이다.

# State: 컴포넌트의 기억 저장소

1. **지역 변수는 렌더링 간에 유지되지 않습니다.** React는 이 컴포넌트를 두 번째로 렌더링할 때 지역 변수에 대한 변경 사항은 고려하지 않고 처음부터 렌더링 합니다.
2. **지역 변수를 변경해도 렌더링을 일으키지 않습니다.** React는 새로운 데이터로 컴포넌트를 다시 렌더링해야 한다는 것을 인식하지 못합니다.

```jsx
const [index, setIndex] = useState(0);
```

- 왼쪽이 state, 오른쪽이 state를 변경하는 함수
- 컴포넌트가 렌더링 간에 어떤 정보를 “기억”해야 할 때 state 변수를 사용합니다.
- state 변수는 `useState` 훅을 호출하여 선언합니다.
- 훅은 use로 시작하는 특별한 함수들입니다. 이들은 state와 같은 React 기능에 “연결”할 수 있도록 해줍니다.
- 훅은 import와 마찬가지로 반드시 호출되어야 합니다. `useState`를 포함한 훅을 호출하는 것은 컴포넌트나 다른 훅의 최상위 수준에서만 유효합니다.
- `useState` 훅은 현재 state와 이를 업데이트할 함수로 이루어진 한 쌍을 반환합니다.
- 여러 개의 state 변수를 가질 수 있습니다. React 내부에서는 그들을 순서대로 매칭합니다.
- state는 컴포넌트에 비공개입니다. 두 곳에서 렌더링하더라도 각각의 복사본은 고유한 state를 가집니다.

# 렌더링 그리고 커밋

- React 앱의 모든 화면 업데이트는 세 단계로 이루어집니다.
    1. 트리거
    2. 렌더링
    3. 커밋
- Strict Mode를 사용하여 컴포넌트에서 실수를 찾을 수 있습니다.
- 렌더링 결과가 이전과 같으면 React는 DOM을 건드리지 않습니다.

# 스냅샷으로서의 State

- state를 설정하면 새 렌더링을 요청합니다.
- React는 컴포넌트 외부에 마치 선반에 보관하듯 state를 저장합니다.
- `useState`를 호출하면 React는 해당 렌더링에 대한 state의 스냅샷을 제공합니다.
- 변수와 이벤트 핸들러는 다시 렌더링해도 “살아남지” 않습니다. 모든 렌더링에는 고유한 이벤트 핸들러가 있습니다.
- 모든 렌더링(및 그 안의 함수)은 항상 React가 그 렌더링에 제공한 state의 스냅샷을 “보게” 됩니다.
- 렌더링 된 JSX에 대해 생각하는 방식과 유사하게 이벤트 핸들러에서 state를 대체할 수 있습니다.
- 과거에 생성된 이벤트 핸들러는 그것이 생성된 렌더링 시점의 state 값을 갖습니다.

# State 업데이트 큐

- state를 설정하더라도 기존 렌더링의 변수는 변경되지 않으며, 대신 새로운 렌더링을 요청합니다.
- React는 이벤트 핸들러가 실행을 마친 후 state 업데이트를 처리합니다. 이를 batching 이라고 합니다.
- 하나의 이벤트에서 일부 state를 여러 번 업데이트하려면 `setNumber(n => n + 1)` 업데이터 함수를 사용할 수 있습니다.

# 객체 state 업데이트 하기

- 리액트의 모든 state를 불변한 것으로 대하세요.
- state에 객체를 저장할 때, 객체를 변경하는 것은 렌더링을 발생시키지 않으며 이전 렌더 “스냅샷”의 state를 바꿀 것입니다.
- 객체를 변경하는 대신 *새로운* 객체를 생성하여 state를 설정함으로써 리렌더링을 일으키세요.
- 객체의 복사본을 만들기 위해 `{...obj, something: 'newValue'}` 객체 전개 구문을 사용할 수 있습니다.
- 전개 구문은 얕습니다. 그것은 한 레벨 깊이만 복사합니다.
- 중첩된 객체를 업데이트하기 위해서는 변경하는 부분에서부터 시작하여 객체의 모든 항목의 복사본을 만들어야 합니다.
- 반복적인 복사 코드를 줄이기 위해서 Immer를 사용하세요.

# 배열 state 업데이트 하기

- 배열을 state로 만들 수 있지만 변경하면 안됩니다.
- 배열을 변경하는 대신 배열의 *새로운* 버전을 만들고, state를 업데이트 해야합니다.
- `[...arr, newItem]` 배열 전개 구문을 사용하여 새 항목을 포함한 배열을 생성할 수 있습니다.
- `filter()`와 `map()`을 사용하여 필터링된 항목들이나 변환된 항목들을 가진 배열을 만들 수 있습니다.
- Immer를 사용하여 코드 간결성을 유지할 수 있습니다.

<aside>
💡 state는 컴포넌트를 업데이트(재렌더링)하기 위한 조건 변수이며, 이를 활용한 리액트의

</aside>